* Let \( v \) be a vector, denote right shift \( v \) by n by \( v^{^\rightarrow  n} \). What is the relationship between the polynomial commitment of \( v \) and \( v^{^\rightarrow  n} \)? Give relationship for both schemes in ((6342705c-75ea-449a-8f7b-8076492c1724)). What about left shift? [[further investigation needed]] [[polynomial commitments]] [[vector commitments]]
* Let \( \sigma: [n] \to [n] \) be a permutation of the set \( [n] := {i \in \Z: 0\le i < n} \). Assume \( \omega \) is a generator of a order \(n\) multiplicative subgroup of a finite field. Let \(f\) (respective \(g\)) be the polynomial satisfies \( f(\omega^i) = x_i \) (respectively \( g(\omega^i) = x_{\omega(i)} \)) for some \( x_i \) in the finite field. What's the relationship between \(f\) and \(g\)? [[further investigation needed]]
* In order to check the Hadamard product of two vectors \(a\) and \(b\) are 0. The paper [[https://eprint.iacr.org/2021/710][VOProof: Efficient zkSNARKs from Vector Oracle Compilers]] construct a polynomial \( h(x) = f(\omega x^{-1}) g(x)) \) where \(f, g\) are the polynomials coresponds to \(a, b\). It then shows the constant term of \(h\) is zero. In order to do so, it requires the prover to show that \( h(x) = \bar{h}(x) - \bar{h}(\gamma x) \). Is it possible to simplify the verification of Hamdamard product is zero with Lagrange polynomial commitment? Take care of the problem that Lagrange polynomial commitment complicates shift operations. [[further investigation needed]]
* What ensures the instructions executed are the instructions from our program (and the exectution flow is legal)? By the initial value of program counter (pc) and enforcing the transition rule of pc? How do we make sure the current pc value coresponds to the correct instructions in the program? Using lookup arguments to ensure pc and ins corespond to the instructions in the program. pp
* How do we ensure the sorting is legal in the memory table? Using permutation arguments and rules to   ensure the table is sorted.
* The limitation of feedback-directed optimization in dynamic language. To what extent, Mike Pall said on [[http://lua-users.org/lists/lua-l/2009-06/msg00071.html][Re: [ANN] llvm-lua 1.0]] is still true?
* [[https://www.microsoft.com/en-us/research/publication/pipezk-accelerating-zero-knowledge-proof-with-a-pipelined-architecture/][PipeZK: Accelerating Zero-Knowledge Proof with a Pipelined Architecture - Microsoft Research]]. Designing ASIC to accelerate multi-scalar multiplication and number theoretic transform.