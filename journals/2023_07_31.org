* How to efficiently implement ~file(1)~? It seems to be a problem of Backtrack and
Branch+Bound. How to parallelize this? [[algorithms]] [[parallel computing]]
* Given a Elliptic curve in the finite field of characteristics \( p \) with generator \( G \) of order \( n \). We sign the message \( z \) (assumed \( z \in \mathbb{Z}_n \), otherwise hashing it to the finite field \( \mathbb{Z}_n \)) by the private key \( a \) (assuming the corresponding public key \( aG = A\)) as follows. [[Elliptic Curve Digital Signature Algorithm]]
** Signature generation
+ Generate a random scalar \( k \), calculate the coordinates \( (x, y) = k G \)
+ Let \( r = x \operatorname{ mod } n \), \( s = k^{-1}(z + ra) \), return \( (r,s) \in \mathbb{Z}_n^2 \)
** Signature verification
+ Calculate \( kG = s^{-1}(z + ra)G = s^{-1}zG + r A \)
+ Verify the x coordinate of \( kG \) is \( r \)
* How to recover public key from EcDSA signature? Why does the recover process does not always work? [[Elliptic Curve Digital Signature Algorithm]]
By the equation \( s = k^{-1}(z + ra) \), we can see that \( a = r^{-1}(z - ks) \), which implies \( aG = r^{-1}(z - ks)G = r^{-1}zG - r^{-1}skG\). We only need to calculate \( kG \) to recover the public key. Let \( (x,y) = kG\) be the coordinates of \( kG \). By the signature creation process, we have \( r = x \mod n \), i.e. \( \exists m \in \mathbb{Z} \) such that \( x = r + mn \). For each \( t \in \mathbb{Z} \), we calculate the y coordinate of the point with x coordinate \( r + tn \) (if such point exists), and then obtain \( aG \) as above (some verification is needed to check if this recovered public key is indeed the wanted public key, e.g. calculating the hash of the recovered public key and comparing it as in bitcoin's secp256k1). This recovery process does not always work because we may need continue indefinitely to obtain a suitable x coordinate of the public key.
*