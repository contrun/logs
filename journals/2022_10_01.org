* How does Haskell lower the processing of lazy variables to machine code? Does Haskell need to check the completeness of a thunk every time it uses a lazy variable? If yes, wouldn't the overhead be unacceptable? Can we use techniques like symbol resolution in dynamic linking? What do we mean when we say laziness makes the performance of Haskell code unpredictable? [[compiling techniques]] [[haskell]]
* How to make the notification of future completion scalable? When the operating system notify the user space program some progress are ready to make. The program has to associate this notification with some future. Can we just use hash map (may be concurrent) like structure for it? How do async executor schedule tasks? Do they just run the first parked thread that is ready to make progress? [[concurrent programming]]
* What is go runtime's scheduling policy? Add a link to the github proposal to make go runtime scheduler better by learning from linux's CFS.
* How is ZIO's fiber implemented? How does it differentiate blocking operations from ZIO's native async operations? What's its scheduling algorithm?
* How can loom improve the async programming of java ecosystem? Is it something like goroutines, i.e. stackful coroutines with a runtime for scheduling?
* How do we yield in user space scheduling? Do we longjmp to the scheduler main loop? We need to keep the jmpbuf somewhere, is there some non-intrusive way to do such thing, e.g. we don't need to pass jmpbuf to every function that may jump to the scheduler.
* How does go runtime manage blocking operations? How does it make use of operating systems' async capability, e.g. a network request can be made non-blocking with epoll, io-uring, etc, how does go translate net.Dial etc to syscalls?
* What does a SQL prepared statement actually do? Is it database dependent? Is this something owned by the database client or something owned by the database? If it is owned by the database, how do we manage its life cycle? A similar object is redis user defined functions.
* What's the best practice of delivering messages with dependency relationship in an unordered fashion? Making the message self-contained may be not practical.