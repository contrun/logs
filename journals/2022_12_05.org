* A cheaper way to transfer assets for exchanges and its users.
Let \( EX \) be a exchange (say bitcoin exchange) with users \( A \) and \( B \), \( C \) be a bitcoin user who has not deposited bitcoins in \( EX \), \( CT \) be a contract implement the relevant logic described below, \( T \) be the Merkle tree in which \( CT \) stores the users and balances information. 
One of the biggest problems of using Merkle tree to store state is that say \( A \) wants to add \( x \) bitcoins to his/her account by transitioning the Merkle tree from \( T \) to \( T' \), after the state transition, the proof of \( B \) having \( y \) bitcoins in \( T \) is no longer a valid proof of \( B \) having \( y \) bitcoins in \( T' \). If we can find a data structure that allows proof to remain valid, the following protocol can be greatly simplified.
+ Setup
\( EX \) deploys the \( CT \) to the network, whose code is public-auditable. Other parties in the protocol verifies the integrity of the contract.
+ Deposit
Say \( A \) want to deposit a balance of \( x \) to the \( EX \). \( A \) send the balance to the contract \( CT \) and
+ Transfer
+ Withdraw