* What problems can [[https://link.springer.com/chapter/10.1007/978-3-642-17373-8_11][Constant-Size Commitments to Polynomials and Their Applications | SpringerLink]] solve?
* Commitment \(cm \in CM\) to a message \(m \in M\) is binding if one can not regret, that is, an adversary has slim change to obtain another message \(m_1\) such that \(m_1\) also has commitment \(cm\).
* Commitment \(cm \in CM\) to a message \(m \in M\) is hiding if one can not find out what \(m\) is, that is, \(cm\) is almost uniformly distributed in \(CM\).
* Examples of commitment schemes.
+ Discrete logarithm commitment (non-standard termiology): Given \(m \in \Z_p\), \(g \in G\) where \(G\) is a group in which the discrete logarithm problem is assumed to be hard to solve, \(g\) is one generator of the group, \(cm(m) = g^m\).
+ Pedersen commitment: Given \(m \in \Z_p\), \(g, h \in G\) where \(G\) is a group in which the discrete logarithm problem is assumed to be hard to solve, \(g, h\) are generators of the group, \(cm(m) = (g^m*h^r, r)\), where the blinding factor \(r\) is a randomly choosed element of \(\Z_p\).
+ Merkle tree commitment: Given message \(m\) and cryptographic hash function \(H\), a binary tree \(T\), let every leaf nodes contains the hash of some message, let every non-leaf node contains the hash of \(H(L||R)\), where \(L\) is the hash result contained in its left child, \(R\) is the hash result contained in its right child. Then the path from message \(m\) to root \(r\), along with the data contained in the nodes is a commitment.
* In which case does Pedersen commitment achieve higher level of security? Say we want to commit three messages \(m_1\), \(m_2\) and \(m_3\), when the discrete logariithm commitment is used, we have \(cm_1 = g^{m_1}\), \(cm_2 = g^{m_2}\) and \(g^{m_3}\). One problem is that if \(m_3 = m_2 + m_1\), then we have \(cm_3 = cm_1 * cm_2\). Conversely, one can infer the relationship of the messages by observing the properties of the commitments, i.e. if \(cm_3 = cm_1 * cm_2\) then we must have \(m_3 = m_2 + m_1\). This is why we need a blinding factor \(r\). We different blinding factors for different messages. One can not infer anything about the messages from the commitments.
* How can one opening a commitment without revealing the message? In polynomial commitment, we commit an polynomial \(p\) to an commitment \(cm\). We want to keep the polynomial secret. When opening the commitment \(cm\), we do not want to give all the coefficients to the verifier (why don't we want to reveal all the coefficeints? Because we can use it to share secrets like Shamir's Secret Sharing?).
* In [[https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing][Shamir's Secret Sharing - Wikipedia]], combining a few participants's information, we can recover the underlying polynomial. But how can we use the polynomial to keep a secret? Let \(s\) be the secret, \(p(x)\) be the polynomial, do we just calculate, \(p(s)\)? Is this process irreversible? What if we want to share a few more secrets? When we have enough points on the curve of this polynomial, aren't we able to recover the curve by interpolation? Any other methods?
It is quite secure as long as the number of secrets we want to protect does not exceed the degree of the polynomial  that hides the secrets. Say we want to hide one secret with a linear function. Even if we give one point on \((s, t)\) on the curve. We still have infinite many functions satisfies \( f(s) = t\). For example any function of the form \( f(x)-t = m(x-s) \). More generally, \( f(x) \) can be the product of a lower degree interpoled from the points and another arbitray polynomial.
Another thing we want to keep in mind is that the seret is normally fixed (i.e. not randomly generated). We can just embedded it into the polynomial (for example, use it as the coefficient of the polynomial). If we want to distribute a new secret, say \(s\) with the polynomial, say \(p\), then we need to obtain the root of \(s\) in \(p\), this may be not easy.
* How to convert a polynomial commitment scheme to a vector commitment scheme?
+ Let \((m_0, m_1, m_2, ... , m_t) \in M^{(t+1)}\) be a vector of messages, let \(f: M \to \Z_p\) be a injective function. We can commit the polynomial \(q = \sum_{i=0}^n{f(m_i) * x^{i}}\).
+ The paper has another method. Let \((k_0, k_1, ... , k_t) \in \Z_p^{(t+1)}\) be a few elements (chosen constants? we can fix a random \( \omega \in \Z_p\), take \((1, \omega, \omega^2, ..., \omega^t)\)) in the finite field. These exists a unique polynomial \(p\) satisfies \(\forall i, p(f(m_i)) = k_i\) (\(\forall i, p(k_i) = f(m_i)\) will also work) is unique, we can commit \(p\).
Why do we commit the polynomial \(p\) instead of the polynomial \(q\)? Is it because the polynomial \(q\) may does not have a degree high enough, while \(p\) is guaranteed to be of degree \(t\)?
* Give a proof of t-Diffie-Hellman inversion (t-DHI) assumption implies Diffie-Hellman assumption.
t-Diffie-Hellman inversion (t-DHI) assumption is the claim that given \((g, g^a, g^{a^2}, ... , g^{a^t})\) it is hard to guess what \(g^{a^(-1)}\), or equivalently \(g^{a^(t+1)}\) is, while decisional Diffieâ€“Hellman (DDH) assumption is the claim that given \((g, g^a, g^b)\), it is hard to guess what \(g^{(ab)}\) is.
* A naive polynomial commitment scheme. Let \(\phi(x) \in \Z_p[x]\) be a polynomial of degree less than \(t\), the polynomial commitment \(cm\) of \(\phi\) is \(\phi(a), g^{\phi(a)}\) where \(a \in \Z_p\) is randomly chosen by the chanllenger. By t-SDHI assumption, this commitment scheme is computationally binding.
* Why the above scheme is not enough to commit a polynomial? Why do we need pairing? Is it for batch commitment? In what sense do we batch commit? On one hand, given a few randomly chosen \(a_i \in \Z_p\), we can generate a few commitments \((\phi(a_i), g^{\phi(a_i)})\), on another hand given a few polynomials  \(\phi_i\), we can generate a few commitments \((\phi_i(a), g^{\phi_i(a)})\). It seems the later one is more useful, as we can create batch commit a few polynomials. But we can also naturally embed a few polynomials into a single polynomial with higher degree and commit it. Why don't we do that? Is batch commit in the first sense useful?
* Given a polynomial \(\phi(x) \in \Z_p[x]\) of degree \(t\), a randomly chosen \(i \in \Z_p\), let \(\phi_i(x)\) be the polynomial satisfies \(\phi(x) - \phi(i) = \phi_i(x)(x - i)\), let the commitment function be \(cm: i \mapsto (g^{\phi(a)}\) and the witness function be \(witness: i \mapsto (\phi(i), \phi_i(i))\). This commitment can be verified as follows. Because \( \phi(a) - \phi_i(i) = \phi_i(a)(a-i) \), \( \frac{g^{\phi(a)}}{g^{\phi_i(i)}} = g^{\phi(a) - \phi_i(i)} = g^{(a-i)\phi_i(i)} = {(\frac{g^a}{g^i})}^{\phi_i(i)} \), the terms \(g^{\phi(a)}, \phi(i), \phi_i(i)\) are all given in the commitment and witness, thus we can verify if the above equality holds with the commitment data.
* What is the benefit of using pairing? We can also transform this commitment scheme with pairing. Let the commitment function be \(cm: i \mapsto ({g}^{\phi(a)}\) and the witness function be \(witness: i \mapsto {g}^{\phi_i(a)} \). \( \frac{{g_T}^{\phi(a)}}{{g_T}^{\phi_i(i)}} = {(\frac{{g_T}^a}{{g_T}^i})}^{\phi_i(i)} \) imples \( e({g}^{\phi(a)}, g)= {g_T}^{\phi(a)} = {g_T}^{\phi_i(i)} * {(\frac{{g_T}^a}{{g_T}^i})}^{\phi_i(i)} = e({g}^{\phi_i(i)}, g) * e(g^{a{\phi_i(i)}}, g^{{-i}{\phi_i(i)}}) = e({g}^{\phi_i(i)}, g) * e(g^{\phi_i(i)}, g^{a -i}) \), where the terms \(({g}^{\phi(a)}, g^{\phi_i(i)})\) are given in the commitment and witness.
* A further twist makes this commitment more secure (akin to twsiting discrete logarithm commitment to Pedersen commitment). GIven two generator \(g, h \in G\) and two polynomial \(\phi(x), \psi(x) \in \Z_p[x]\), let the commitment function \( cm: i \mapsto g^{\phi(a)} * h^{\psi(a)} \), the witness function \( witness: i \mapsto g^{\phi_i(i)} * h^{\psi_i(i)} \).  \(h\ h^{\psi(a)} \) serves the role of \(h^r\) in Pedersen commitment. We can verify the commitment and witness in the same way.