* What problem can [[https://link.springer.com/chapter/10.1007/978-3-642-17373-8_11][Constant-Size Commitments to Polynomials and Their Applications | SpringerLink]] solve?
* Commitment \(cm \in CM\) to a message \(m \in M\) is binding if one can not regret, that is, an adversary has slim change to obtain another message \(m_1\) such that \(m_1\) also has commitment \(cm\).
* Commitment \(cm \in CM\) to a message \(m \in M\) is hiding if one can not find out what \(m\) is, that is, \(cm\) is almost uniformly distributed in \(CM\).
* Examples of commitment schemes.
+ Given \(m \in \Z_p\), \(g \in G\) where \(G\) is a group in which the discrete logarithm problem is assumed to be hard to solve, \(g\) is one generator of the group, \(cm(m) = g^m\).
+ Pedersen commitment: Given \(m \in \Z_p\), \(g, h \in G\) where \(G\) is a group in which the discrete logarithm problem is assumed to be hard to solve, \(g, h\) are generators of the group, \(cm(m) = (g^m*h^r, r)\), where the blinding factor \(r\) is a randomly choosed element of \(\Z_p\).
+ Merkle tree commitment: Given message \(m\) and cryptographic hash function \(H\), a binary tree \(T\), let every leaf nodes contains the hash of some message, let every non-leaf node contains the hash of \(H(L||R)\), where \(L\) is the hash result contained in its left child, \(R\) is the hash result contained in its right child. Then the path from message \(m\) to root \(r\), along with the data contained in the nodes is a commitment.
* How can one opening a commitment without revealing the message? In polynomial commitment, we commit an polynomial \(p\) to an commitment \(cm\). We want to keep the polynomial secret. When opening the commitment cm, we do not want to give all the coefficients to the verifier (why don't we want to reveal all the coefficeints? Because we can use it to share secrets like Shamir's Secret Sharing?).
* In [[https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing][Shamir's Secret Sharing - Wikipedia]], combining a few participants's information, we can recover the underlying polynomial. But how can we use the polynomial to keep a secret? Let \(s\) be the secret, \(p(x)\) be the polynomial, do we just calculate, \(p(s)\)? Is this process irreversible? What if we want to share a few more secrets? When we have enough points on the curve of this polynomial, aren't we able to recover the curve by interpolation? Any other methods?
* How to convert a polynomial commitment scheme to a vector commitment scheme?
+ Let \((m_0, m_1, m_2, ... , m_t) \in M^t\) be a vector of messages, let \(f: M \to \Z_p\) be a injective function. We can commit the polynomial \(q = \sum_{i=0}^n{f(m_i) * x^{i}}\).
+ The paper has another method. Let \((k_0, k_1, ... , k_t) \in \Z_p\) be a few elements (chosen constants?) in the finite field. These exists a unique polynomial \(p\) satisfies \(\forall i, p(f(m_i)) = k_i\). is unique, we can commit \(p\).
Why do we commit the polynomial \(p\) instead of the polynomial \(q\)? Is it because the polynomial \(q\) may does not have a degree high enough, while \(p\) is guaranteed to be of degree \(t\)?
* Give a proof of t-Diffie-Hellman inversion (t-DHI) assumption implies Diffie-Hellman assumption.
t-Diffie-Hellman inversion (t-DHI) assumption is the claim that given \((g, g^a, g^{a^2}, ... , g^{a^t})\) it is hard to guess what \(g^{a^(-1)}\), or equivalently \(g^{a^(t+1)}\) is, while decisional Diffieâ€“Hellman (DDH) assumption is the claim that given \((g, g^a, g^b)\), it is hard to guess what \(g^{(ab)}\) is.
* A naive polynomial commitment scheme. Let \(\phi(x) \in \Z_p[x]\) be a polynomial of degree less than \(t\), the polynomial commitment \(cm\) of \(\phi\) is \(\phi(a), g^{\phi(a)}\) where \(a \in \Z_p\) is randomly chosen by the chanllenger. By t-SDHI assumption, this commitment scheme is computationally binding.
* Why the above scheme is not enough to commit a polynomial? Why do we need pairing? Is it for batch commitment? In what sense can we batch commit? On one hand, given a few randomly chosen \(a_i \in \Z_p\), we can generate a few commitments \((\phi(a_i), g^{\phi(a_i)})\), on another hand given a few polynomials  \(\phi_i\), we can generate a few commitments \((\phi_i(a), g^{\phi_i(a)})\). It seems the later one is more useful, as we can create batch commit a few polynomials. But we can also naturally embed a few polynomials into a single polynomial with higher degree and commit it. Why don't we do that?
* Given a polynomial \(\phi(x) \in \Z_p[x]\) of degree \(t\), a randomly chosen \(i \in \Z_p\), let \(\phi_i(x)\) be the polynomial satisfies \(\phi(x) - \phi(i) = \phi_i(x)(x - i)\), let the commitment function be \(cm: i \mapsto (g^{\phi(a)}\) and the witness function be \(witness: i \mapsto (\phi(i), \phi_i(i))\). This commitment can be verified as follows. Because \( \phi(a) - \phi_i(i) = \phi_i(a)(a-c) \), \( \frac{g^{\phi(a)}}{g^{\phi_i(i)}} = g^{\phi(a) - \phi_i(i)} = g^{(a-i)\phi_i(i)} = {(\frac{g^a}{g^i})}^{\phi_i(i)} \), the terms \(g^{\phi(a)}, \phi(i), \phi_i(i)\) are all given in the commitment and witness, thus we can verify if the above equality holds with the commitment data.
* What is the benefit of using pairing? We can also transform this commitment scheme with pairing. Let the commitment function be \(cm: i \mapsto ({g}^{\phi(a)}\) and the witness function be \(witness: i \mapsto {g}^{\phi_i(a)} \). \( \frac{{g_T}^{\phi(a)}}{{g_T}^{\phi_i(i)}} = {(\frac{{g_T}^a}{{g_T}^i})}^{\phi_i(i)} \) imples \( e({g}^{\phi(a)}, g)= {g_T}^{\phi(a)} = {g_T}^{\phi_i(i)} * {(\frac{{g_T}^a}{{g_T}^i})}^{\phi_i(i)} = e({g}^{\phi_i(i)}, g) * e(g^{a{\phi_i(i)}}, g^{{-i}{\phi_i(i)}}) = e({g}^{\phi_i(i)}, g) * e(g^{\phi_i(i)}, g^{a -i}) \), where the terms \(({g}^{\phi(a)}, g^{\phi_i(i)})\) are given in the commitment and witness.