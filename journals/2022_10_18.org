* How to build a parser automatically by converting the context free gramma to a push-down automaton? [[compiling techniques]]
* Pumping lemma of regular languages: Let \( L \) be a regular language, \( \exists \) a constant \( n \) (depending on \( L \)) such that \( \forall w \in L \) such that \( \|w\| \ge n \), \( \exists x, y, z\) such that \( w = xyz \), \( y \ne \epsilon \),  \( \| xy\| \le n \), \( \forall k \ge 0, xy^kz \in L \). [[Introduction to Automata Theory, Languages, and Computation]] [[theoretical computer science]]
* How can pumping lemma hold for language with finite many strings, e.g. \( L = {0} \)? Is \( L \) not a regular language? [[Introduction to Automata Theory, Languages, and Computation]] [[theoretical computer science]] 
The proof of pumping lemma for regular language assume the existence of a string with length more than the states of the corresponding finite-state automaton (it then continues by applying pigeonhole principle to the set of states in the transtion path). But the question is how can we be sure there exists a string of such length? These strings may not belong to the language. Does this implies the cardinality regular languages are infinite?
* Can regular expression matching libraries be more effficient if it is implemented with finite state automatons? How can we deal with non-standard extensions to regular expression (like look-ahead,l ook-behind and backtrack)? How can we model non-standard extensions in regular expression, i.e. do they have well-known relationship to well-known automatons (like push-down automatons)? [[regular expressions]] [[automata]]
* [[https://www.noulakaz.net/2007/03/18/a-regular-expression-to-check-for-prime-numbers/][A regular expression to check for prime numbers â€” Noulakaz]] [[regular expressions]]
* Is there any multi-signature algorithms that aggregate multiple signatures without before-hand collaboration, i.e. let \( (pk_i, m, s_i)_{i=1}^n \) be a set of valid signatures fo