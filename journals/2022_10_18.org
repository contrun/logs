* How to build a parser automatically by converting the context free gramma to a push-down automaton? [[compiling techniques]]
* Pumping lemma of regular languages: Let \( L \) be a regular language, \( \exists \) a constant \( n \) (depending on \( L \)) such that \( \forall w \in L \) such that \( \|w\| \ge n \), \( \exists x, y, z\) such that \( w = xyz \), \( y \ne \epsilon \),  \( \| xy\| \le n \), \( \forall k \ge 0, xy^kz \in L \). [[Introduction to Automata Theory, Languages, and Computation]] [[theoretical computer science]]
* How can pumping lemma hold for language with finite many strings, e.g. \( L = {0} \)? Is \( L \) not a regular language? [[Introduction to Automata Theory, Languages, and Computation]] [[theoretical computer science]] 
The proof of pumping lemma for regular language assume the existence of a string with length more than the states of the corresponding finite-state automaton (it then continues by applying pigeonhole principle to the set of states in the transtion path). But the question is how can we be sure there exists a string of such length? These strings may not belong to the language. Does this implies the cardinality regular languages are infinite?
* Can regular expression matching libraries be more effficient if it is implemented with finite state automatons? How can we deal with non-standard extensions to regular expression (like look-ahead,l ook-behind and backtrack)? How can we model non-standard extensions in regular expression, i.e. do they have well-known relationship to well-known automatons (like push-down automatons)? [[regular expressions]] [[automata]]
* [[https://www.noulakaz.net/2007/03/18/a-regular-expression-to-check-for-prime-numbers/][A regular expression to check for prime numbers — Noulakaz]] [[regular expressions]]
* Is there any multi-signature algorithms that can aggregate multiple signatures without before-hand collaboration, i.e. let \( (pk_i, m, s_i)_{i=1}^n | s_i \text{ is a signature of } pk_i \text{ to the message } m_i \) be an arbitrary set of valid signatures (\( pk_i \) may not generate signatures based on the existence of other \({pk_j}\)), can we just compress these signatures? [[signature schemes]]
* Why is dotty named dotty? [[https://lampwww.epfl.ch/~amin/dot/fool.pdf][Dependent Object Types: Towards a foundation for Scala’s type system]] [[scala]]
* Domain separation tag like mechanism for private key?
:PROPERTIES:
:id: 634e5b8a-bfbd-41dc-adcf-c4221f4174dd
:END:
We use domain separation tag to avoid collision in different application domain. In elliptic curve cryptography, the public key is just a scalar multipled with the base point.