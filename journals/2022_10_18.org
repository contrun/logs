* How to build a parser automatically by converting the context free gramma to a push-down automaton? [[compiling techniques]]
* Pumping lemma of regular languages: Let \( L \) be a regular language, \( \exists \) a constant \( n \) (depending on \( L \)) such that \( \forall w \in L \) such that \( \|w\| \ge n \), \( \exists x, y, z\) such that \( w = xyz \), \( y \ne \epsilon \),  \( \| xy\| \le n \), \( \forall k \ge 0, xy^kz \in L \). [[Introduction to Automata Theory, Languages, and Computation]] [[theoretical computer science]]
* How can pumping lemma hold for language with finite many strings, e.g. \( L = {0} \)? Is \( L \) not a regular language? [[Introduction to Automata Theory, Languages, and Computation]] [[theoretical computer science]] 
The proof of pumping lemma for regular language assume the existence of a string with length more than the states of the corresponding finite-state automaton (it then continues by applying pigeonhole principle to the set of states in the transtion path). But the question is how can we be sure there exists a string of such length? These strings may not belong to the language. Does this imply the cardinality regular languages are infinite?
* Can regular expression matching libraries be more effficient if it is implemented with finite state automatons? How can we deal with non-standard extensions to regular expression (like look-ahead,l ook-behind and backtrack)? How can we model non-standard extensions in regular expression, i.e. do they have well-known relationship to well-known automatons (like push-down automatons)? [[regular expressions]] [[automata]]
* [[https://www.noulakaz.net/2007/03/18/a-regular-expression-to-check-for-prime-numbers/][A regular expression to check for prime numbers — Noulakaz]] [[regular expressions]]
* Is there any multi-signature algorithms that can aggregate multiple signatures without before-hand collaboration, i.e. let \( (pk_i, m, s_i)_{i=1}^n | s_i \text{ is a signature of } pk_i \text{ to the message } m_i \) be an arbitrary set of valid signatures (\( pk_i \) may not generate signatures based on the existence of other \({pk_j}\)), can we just compress these signatures? [[signature schemes]]
* Why is dotty named dotty? [[https://lampwww.epfl.ch/~amin/dot/fool.pdf][Dependent Object Types: Towards a foundation for Scala’s type system]] [[scala]]
* Domain separation tag like mechanism for private key? [[collision attacks]] [[key derivation functions]]
:PROPERTIES:
:id: 634e5b8a-bfbd-41dc-adcf-c4221f4174dd
:END:
+ We use domain separation tag to avoid collision in different application domains (like salt in hashing). In elliptic curve cryptography, the public key is just a scalar multipled with the base point. When we use brute force to obtain the private key from the public key, all applications used the same curve is susceptible. This does not really seem to be defect in the real world. Is this because the secret key used will almost certainly freshly-generated in real world applications?
+ A naive implementation would be tweaking the secret key by adding itwith \( H(\text{dst}) \) where \( H \) is a hash function which maps domain separation tag \(\text{dst}\) to a scalar.
+ This is also akin to key derivation functions. Key derivation functions have somewhat similar mechanism, but it is normally used to derive a symmetric key.
+ We can apply this kind of mechanism to [[https://en.bitcoinwiki.org/wiki/Mnemonic_phrase][BIP39 (Mnemonic Phrase) - Bitcoin Seed Passphrase - BitcoinWiki]]. In this way, we can use the saem mnemonic phrase and generate different keys for different wallets.
* Prove the security of BLS signature scheme providing that the computational Diffe-Hellman problem is hard to solve.
+ Signature generation: Let \( (sk, pk) \) be a key pair, \( m \) be a message to be signed (assume \( m \) is a point in the elliptic curve, otherwise hash it to the curve), the BLS signature of \( m \) is \( \sigma = sk * m \).
+ Signature verification: let \( e: G_1 \times G_2 \to G_T \) be a bilinear pairing. If \( e(pk, m) = e(g, \sigma) \), then output VALID, else INVALID.
+