* What is interaction combinators? Why are they so great? [[theoretical computer science]] [[interaction combinators]]
[[https://github.com/Kindelia/manifesto][Kindelia/manifesto]]
#+BEGIN_QUOTE
This raises the question: is there a model of computation, which, like the Turing Machine, has a reasonable physical implementation, and yet, like the Lambda Calculus, has a robust logical interpretation? In 1997, Yves Lafont proposed a new alternative, the Interaction Combinators, on which substitution is broken down into 2 fundamental laws: commutation, which creates and copies information, and annihilation, which observes and destroys information. In a sense, this may resemble SKI combinators, but that isn't a good analogy, since SKI combinators still include non-atomic operations: K may erase an unboundedly large structure, and S may copy an unboundedly large structure. The charm, and elegance, of the Interaction Combinators is that its reduction laws are truly atomic: each operation can be completed in a constant amount of steps, and has a clear physical mapping. Not only that, they're inherently parallel, in the same sense that the Lambda Calculus has been claimed to be, in theory, but without the issues that let it to be, in practice.
#+END_QUOTE
* Which of those proofs (lookup arguments, permutation arguments, range proofs) are agnostic to the backend (FRI or KZG)? [[fast Reed-Solomon interactive oracle proofs of proximity]] [[KZG commitments]]
It seems that all these arguments/proofs are agnostic to the backend. Subset arguments can be constructed from permutation argument (see ((637adbd4-5c73-4cb4-b2cf-64828ab71858)) ). Subset arguments = lookup arguments. Range proofs can